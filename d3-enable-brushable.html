<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">
<!-- <link rel="import" href="dist/polymer.html"> -->
<link rel="import" href="../d3-element/d3-element.html">
<!--
An element for enabling zooming of content

@demo
-->
<dom-module id="d3-enable-brush">
  <template>
    <g id="brush" class="d3-brush" hidden="{{!active}}">
      <content></content>
    </g>
  </template>
</dom-module>
<script>
(function() {
  'use strict';

  Polymer({

    is: 'd3-enable-brush',

    extends: 'g',
    namespace: 'http://www.w3.org/2000/svg',

    properties: {
      /**
       * brush will show up onely when `active` is `true`
       */
      active: {
        type: Boolean,
        value: true,
        observer: '_activeChange(active)'
      }
      /**
       * `selected`, an array storing nodes selected by the brush quadtree
       */
      // selected: {
      //   type: Array,
      //   notify: true,
      //   value: function() {
      //     return [];
      //   }
      // }
    },
    // observers: [
    //   '_tranformChanged(translate,scale)'
    // ],

    attached: function() {
      this._initBrush();
    },

    detached: function() {
      this._clearBrush();
      this.brush = null;
    },

    // getNodes: function() {
    //   //virtual
    //   console.error('getNodes need to be overriden');
    // },

    getPoints: function() {
      //virtual
      console.error('getPoints need to be overriden');
    },

    _activeChange: function(active) {
      if (active) {
        this._resetBrushSize();
      } else {
        this._clearBrush();
      }
    },

    _clearBrush: function() {
      if (this.brush) {
        d3.select(this.$.brush).call(brush.clear);
      }
    },

    _initBrush: function() {
      var d3Brush = d3.select(this.$.brush),
        me = this,
        quad;

      var brush = this.brush = d3.svg.brush() // we keep the brush to be able to properly clear it
        .on('brushstart', brushstarted)
        .on('brush', brushed);

      this._resetBrushSize(brush);

      d3Brush
        .call(brush)
        .call(brush.event);

      var nodes = this.getActiveLayout().nodes();

      function brushed() {
        if (!d3.event.sourceEvent) {
          return;
        } // only transition after input
        var extent = brush.extent();
        nodes.each(function(d) {
          d.quadWasSelected = d.quadSelected;
          d.quadSelected = false;
        });
        // search(me.getQuadtree(), extent[0][0], extent[0][1], extent[1][0], extent[1][1]);
        search(quad, extent[0][0], extent[0][1], extent[1][0], extent[1][1]);
        nodes.each(function(d) {
          if (d.quadSelected) {
            me.selectNode(d)
            // me.push('selected', d);
          }
          if (d.quadWasSelected && !d.quadSelected) {
            me.deselectNode(d)
            // me.slice('selected', me.selected.indexOf(d), 1);
          }
          return false;
        });
      }

      function brushstarted() {
        // var size = me.getD3Layout().size();

        quad = d3.geom.quadtree()
          // .extent([
          //   [-1, -1],
          //   [size[0] + 1, size[1] + 1]
          // ])
          .x(function(d) {
            return d.y;
          }) // x and y anre invered in the classecal layout
          .y(function(d) {
            return d.x;
          // })(me.getPoints());
          })(nodes);
      }

      // Find the nodes within the specified rectangle.
      function search(quadtree, x0, y0, x3, y3) {
        quadtree.visit(function(node, x1, y1, x2, y2) {
          var p = node.point;
          if (p) {
            p.quadSelected = (p.y >= x0) && (p.y < x3) && (p.x >= y0) && (p.x < y3);
          }
          return x1 >= x3 || y1 >= y3 || x2 < x0 || y2 < y0;
        });
      }
    },

    _resetBrushSize: function() {
      // we would need to call this 
      var viewBox = this.viewBox.baseVal,
        width = viewBox.width,
        height = viewBox.height,
        point, owner, x0, x1, y0, y1, m;

      owner = this.ownerSVGElement;
      point = owner.createSVGPoint();
      m = owner.getTransformToElement(this.$.brush);

      point.x = 0;
      point.y = 0;
      point = point.matrixTransform(m);
      x0 = point.x;
      y0 = point.y;

      point.x = width;
      point.y = height;
      point = point.matrixTransform(m);
      x1 = point.x;
      y1 = point.y;

      var x = d3.scale.identity().domain([x0, x1]),
        y = d3.scale.identity().domain([y0, y1]);

      this.brush
        .x(x)
        .y(y);
    },

  });
})();
</script>
